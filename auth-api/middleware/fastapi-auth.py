from fastapi import HTTPException, Depends, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
import jwt
import os
from typing import Optional, Dict, Any

security = HTTPBearer()

class JWTAuthMiddleware:
    """
    JWT Authentication Middleware for FastAPI APIs
    This middleware validates JWT tokens generated by the Auth API
    """
    
    def __init__(self):
        self.secret_key = os.getenv("JWT_SECRET_KEY")
        self.algorithm = os.getenv("JWT_ALGORITHM", "HS256")
        
        if not self.secret_key:
            raise ValueError("JWT_SECRET_KEY environment variable is not set")

    def verify_token(self, credentials: HTTPAuthorizationCredentials = Depends(security)) -> Dict[str, Any]:
        """
        Verify JWT token and return decoded payload
        """
        try:
            payload = jwt.decode(
                credentials.credentials, 
                self.secret_key, 
                algorithms=[self.algorithm]
            )
            return payload
        except jwt.ExpiredSignatureError:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail={
                    "success": False,
                    "message": "Token has expired",
                    "error": "TOKEN_EXPIRED"
                }
            )
        except jwt.JWTError:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail={
                    "success": False,
                    "message": "Invalid token",
                    "error": "INVALID_TOKEN"
                }
            )

    def require_role(self, allowed_roles: list):
        """
        Role-based authorization decorator
        """
        def role_checker(user: Dict[str, Any] = Depends(self.verify_token)):
            user_role = user.get("role")
            
            if user_role not in allowed_roles:
                raise HTTPException(
                    status_code=status.HTTP_403_FORBIDDEN,
                    detail={
                        "success": False,
                        "message": "Insufficient permissions",
                        "error": "INSUFFICIENT_PERMISSIONS",
                        "required_roles": allowed_roles,
                        "user_role": user_role
                    }
                )
            return user
        
        return role_checker

    def optional_auth(self, credentials: Optional[HTTPAuthorizationCredentials] = Depends(security)):
        """
        Optional authentication - validates token if present but doesn't require it
        """
        if not credentials:
            return None
            
        try:
            payload = jwt.decode(
                credentials.credentials, 
                self.secret_key, 
                algorithms=[self.algorithm]
            )
            return payload
        except (jwt.ExpiredSignatureError, jwt.JWTError):
            return None

# Create global instance
jwt_auth = JWTAuthMiddleware()

# Convenience functions
def verify_token(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """Verify JWT token and return decoded payload"""
    return jwt_auth.verify_token(credentials)

def require_role(allowed_roles: list):
    """Require specific role(s) to access endpoint"""
    return jwt_auth.require_role(allowed_roles)

def optional_auth(credentials: Optional[HTTPAuthorizationCredentials] = Depends(security)):
    """Optional authentication - validates token if present"""
    return jwt_auth.optional_auth(credentials)

def require_admin():
    """Require admin role to access endpoint"""
    return require_role(["admin"])

def require_user_or_admin():
    """Require user or admin role to access endpoint"""
    return require_role(["user", "admin"])
